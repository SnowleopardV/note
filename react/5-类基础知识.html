<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>

<body>

  <script>
    class Boy {}
    class Girl {}

    const b = new Boy()
    const g = new Girl()

    console.log(b)
    console.log(g)

    class Person {
      // 构造器方法
      constructor(name, age) {
        // 构造器中this指向实例化之后的对象
        // 构造器内的属性和方法将挂在在实例化之后的对象上
        this.name = name
        this.age = age
        this.laugh = () => {
          console.log('I am Happy')
        }
      }
      // 一般方法
      // speak的方法是放在了类的原型对象上
      // speak中的this指向实例化之后的对象
      speak() {
        console.log(33, this)
        console.log(`我叫${this.name}, 我今年${this.age}`)
      }
    }

    // 类的继承
    class Student extends Person {

    }

    class Teacher extends Person {
      constructor(name, age, grade) {
        // 必须调用super, 执行父类的constructor
        super(name, age)
        this.grade = grade
        this.haha = () => console.log('哈哈哈')
      }

      // 重写从父类继承过来的方法
      speak() {
        console.log(33, this)
        console.log(`我叫${this.name}, 我今年${this.age}, 我${this.grade}年级`)
      }

      // 新增自己的方法
      teach() {
        console.log('I am teaching')
      }
    }

    const p1 = new Person('Tom', 20)
    const p2 = new Person('Jack', 21)
    const s1 = new Student('Lily', 23)
    const t1 = new Teacher('Lucy', 25, 3)
    console.log(p1)
    console.log(p2)
    console.log(t1)
    p1.speak()
    p2.speak()
    s1.speak()
    t1.speak()
    t1.teach()
    t1.laugh()
  </script>
</body>

</html>