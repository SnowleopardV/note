<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>

<body>

  <script>
    class Boy {}
    class Girl {}

    const b = new Boy()
    const g = new Girl()

    // console.log(b)
    // console.log(g)

    class Person {
      // 构造器方法
      constructor(name, age) {
        // 构造器中this指向实例化之后的对象
        // 构造器内的属性和方法将挂在在实例化之后的对象上
        this.name = name
        this.age = age
        this.laugh = () => {
          console.log('I am Happy')
        }
      }
      // 静态属性
      // 只存在在类上, 不在类实例化之后的对象上, 所以只能通过类来访问, Person.money
      static money = 900000
      // 类中可以直接写赋值语句, 表示给Person的实例对象添加一个属性sex, 值为'male' 
      sex = 'male'
      speak = () => console.log(38, this)
      // 一般方法,
      // 通过声明式, speak的方法是放在了类的原型对象上
      // 在通过类实例化之后的对象调用speak方法时, speak中的this指向实例化之后的对象
      speak() {
        console.log(33, this, this.money)
        console.log(`我叫${this.name}, 我今年${this.age}`)
      }
    }

    console.log(46, Person.money)
    const pp = new Person('lilei', 29)
    console.log(pp.money)

    // 类的继承
    class Student extends Person {

    }

    class Teacher extends Person {
      constructor(name, age, grade) {
        // 必须调用super, 执行父类的constructor
        // super的含义是委托父类创建并初始化对象后将创建的对象返回到当前环境，作为当前实例化的this
        super(name, age)
        this.grade = grade
        this.haha = () => console.log('哈哈哈')
      }

      // 重写从父类继承过来的方法
      speak() {
        console.log(33, this)
        console.log(`我叫${this.name}, 我今年${this.age}, 我${this.grade}年级`)
      }

      // 新增自己的方法
      teach() {
        console.log('I am teaching')
      }

      logThis() {
        console.log(67, this)
      }
    }


    const t1 = new Teacher('Lucy', 25, 3)
    // 类一般方法上的this指向
    t1.logThis()
    const log = t1.logThis
    log()

    const p1 = new Person('Tom', 20)
    const p2 = new Person('Jack', 21)
    const s1 = new Student('Lily', 23)
    console.log(p1)
    console.log(p2)
    console.log(t1)
    p1.speak()
    p2.speak()
    s1.speak()
    t1.speak()
    t1.teach()
    t1.laugh()

    const thisObj = {
      printThis() {
        console.log(this)
      }
    }
    thisObj.printThis()

    const print = thisObj.printThis
    print()

    function demo() {
      console.log(102, this)
    }

    function demo2() {
      'use strict'
      console.log(107, this)
    }

    demo()
    demo2()

    class MyComponent {
      constructor(name) {
        this.name = name
        this.say = () => {
          console.log(117)
        }
        this.go2 = this.go2.bind(this)
      }

      say() {
        console.lg(119)
      }

      go() {
        console.log(126, this)
      }

      go2() {
        console.log(126, this)
      }

      click() {
        this.go()
      }

      click2() {
        const gofn = this.go2
        gofn()
      }
    }
    const myComponent = new MyComponent('Lilei')
    myComponent.say()
    myComponent.go()
    myComponent.click()
    myComponent.click2()
  </script>
</body>

</html>